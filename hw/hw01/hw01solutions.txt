/* 
GA DATA SCIENCE LA
WINTER 2014-2015
HOMEWORK 1 

SOLUTIONS
BY NICK STUCKY-MACK
*/ 

This homework will hone in some basic data processing skills that we have learned over the first few weeks of class. 

Make sure you have the jobs.tsv file we used in class. (If you don't have it, get it off of github.) 

1. 
a. Using only Linux commands, calculate on how many lines the phrase 'professionals wanted' occurs in jobs.tsv. 

	20 lines 

	If you ignored case, which is a smart thing to do even though it deviates from the most literal interpretation of the problem, you should have gotten the answer 21 lines. 

	You could have gotten this using an intermediate file as follows: 

		grep 'professionals wanted' jobs.tsv > tmp.txt
		wc -l tmp.txt

b. Now do it in only one line (if you did not before) using pipe |

	As the question suggests, you can do this in many different ways. One would be: 

		cut -f1 jobs.tsv | grep -i 'professionals wanted' | wc -l 

	Note that I have chosen to use the -i flag to ignore case.

	As always, if you don't know what any of the flags mean, use the manual! (e.g., man grep)

c. Now do it in only one command -- no pipes allowed. (Hint: Use the flags, Luke.)

		grep -i -c 'professionals wanted' jobs.tsv 

	Note that, often, single-character flags can be combined. In this case, we could write this as: 

		grep -ic 'professionals wanted' jobs.tsv

2. 
a. How many listings are in either New Jersey or New York? 
-- You will need to use a regular expression (we call it a "regex" for short) for this. (You may remember regexes from the Google Code videos on Python, though I don't expect you to have gotten at the time why you would ever use a regex.) To learn a little more about regular expressions in Linux, look here: https://www.digitalocean.com/community/tutorials/using-grep-regular-expressions-to-search-for-text-patterns-in-linux

	We will look for listings where the state column takes either the value "NJ" or the value "NY". The regular expression we want to accomplish this uses grouping. There are a few ways to do this. One would be: 

		grep -cE '\tN(J|Y)\t' jobs.tsv 

	or equivalently: 

		egrep -c '\tN(J|Y)\t' jobs.tsv

	We include the tabs \t on either side to make sure this expression occurs only in its own column (not in other text).

	You should get a count of 90. 

b. Now do it only one line with only one pipe. 

	Here is one way to do this: 

		cut -f3 jobs.tsv | grep -cE 'N(J|Y)'

	Note that this is slightly more robust than our earlier answer, because it ensures that we only find matches in the State column (column 3). Nonetheless, we get the same answer as before. 

Well, that was fun. But you may be thinking that having this data in a database would have made answering these questions even easier. Since our data is very neatly structured -- tab separated, with fields consistent across lines -- a relational database is a good choice. Let's put it in a MySQL database. 

3. 
Start up your MySQL, and create a database if you don't have one. You can call it Jobs if you want. 
a. Create the schema for a jobs table. Text fields should be varchar and numerical fields (lat and lon) should be floats. 

		CREATE TABLE jobs (
			text varchar(255), 
			city varchar(255), 
			state varchar(255), 
			country varchar(255), 
			lat float, 
			lon float
		);

	Using 255 characters for the state and country fields, as I did here, is really an egregious waste, since those fields can only be 2 characters each. We often use 255 as a default for varchar fields, and that's why I did that here. But if you wanted to be efficient, you could really just make state and country varchar(4) and save a lot of space. 

b. Load the data from jobs.tsv into your jobs table. (Remember the command for that?) 

		LOAD DATA LOCAL INFILE 'jobs.tsv' INTO TABLE jobs
		FIELDS DELIMITED BY '\t' 
		LINES TERMINATED BY '\n';

	Since our fields are delimited by the default value, \t, and our lines are terminated by the default value \n, the "FIELDS DELIMITED BY '\t' LINES TERMINATED BY '\n'" command in the above could actually be ommitted (but I wanted everyone to see what it looks like anyway). 

c. Now that the data is loaded, verify your answer to problem 2. 

		SELECT COUNT(*) 
		FROM jobs 
		WHERE (state = 'NY' or state = 'NJ'); 

	You should still get 90.

4. 
Now that the data is loaded, let's use SQL to make a whole lot of data analysis really easy. Find the top 10 states by number of listings. 

		SELECT state, COUNT(*) 
		FROM jobs
		GROUP BY state 
		ORDER BY COUNT(*) DESC 
		LIMIT 10;

Now for some Python practice with Fibonacci numbers.
If you're not familiar with the Fibonacci sequence, Wikipedia it. 
5. 
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. 

And here is how we will do it without crashing our computers: 
a. A rule-based sequence, like the Fibonacci sequence, is a perfect use-case for generators. The generator only needs a small amount of memory no matter how many terms of the sequence we want to generate, while a list would have to hold the entire sequence in memory. (In CS-speak, the generator takes constant memory, while the list takes linear memory.) This is difficult, as the sequence is infinite. 

So, create a generator to produce the Fibonacci sequence. 

b. Now write another method to solve the original problem of summing even-valued fibonacci numbers. 

	I'm putting the answers to a and b together here to make it easier to paste into code if you want to. 

	Let's first do this by creating a class (you can call it Fib) with a method (you can call it getnext()) that returns the next Fibonacci element in the sequence. 

	There are obviously tons of ways of doing this. Here is one.

		class Fib(object): 
			def __init__(self): 
				pass

			def __iter__(self): 
				return self

			def getnext(self): 
				if not hasattr(self, 'pred'): 
					self.pred = 1 
					return self.pred 
				if not hasattr(self, 'cur'): 
					self.cur = 1 
					return self.cur 
				self.pred, self.cur = self.cur, self.pred + self.cur
				return self.cur

			def get_sum_of_evens_lt(self, upper_limit): 
				fibsum = 0  
				while True: 
					nxt = self.getnext()
					if nxt > upper_limit: 
						return fibsum
					if not (nxt % 2): 
						fibsum += nxt 

	Let's have a useful digression for a moment. 

	While I wanted to practice building classes here, as a matter of fact a better way to write generators is to view them as functions. This is because we can use the yield statement here, which is like return but doesn't erase everything that's happened inside the function yet (maintains state). When you write generators in the future, it may be useful to write them as functions. Here is how we would do this problem using functions. 

		def fibgen(): 
			pred = 1 
			yield pred 
			cur = 1 
			yield cur
			while True: 
				pred, cur = cur, pred + cur 
				yield cur

		def get_sum_of_evens_lt(upper_limit): 
			fg = fibgen()
			fibsum = 0 
			while True: 
				nxt = fg.next() 
				if nxt > upper_limit: 
					return fibsum 
				if not (nxt % 2): 
					fibsum += nxt

		get_sum_of_evens_lt(4000000)

	The answer is 4613732. 

EXTRA: If you want more python practice and like solving riddles, check this out: http://www.pythonchallenge.com/